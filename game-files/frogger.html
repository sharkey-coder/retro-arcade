<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frogger (8-Bit Edition)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../arcade-theme.css">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            padding: 10px;
        }
        
        .game-container {
            display: flex;
            flex-direction: row;
            gap: 15px;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
            height: 100%;
        }
        
        .game-board {
            background: var(--bg-black);
            border: 4px solid var(--border-white);
            padding: 5px;
            box-shadow: 0 0 0 4px var(--shadow-black-light), 0 3px 24px var(--shadow-black-medium);
            position: relative;
            flex-shrink: 0;
        }
        
        canvas {
            display: block;
            background: var(--bg-canvas);
            max-width: 100%;
            max-height: calc(100vh - 40px);
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 1;
            min-width: 0;
            max-width: 300px;
        }
        
        .score-panel, .controls, .legend {
            background: var(--bg-panel);
            border: 3px solid var(--border-white);
            border-radius: 4px;
            box-shadow: 0 0 0 3px var(--shadow-black-light), 0 3px 12px var(--shadow-black-medium);
        }
        
        .score-panel {
            padding: 15px 20px;
        }
        
        .score-panel h2 {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .score-item {
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .controls {
            padding: 15px 20px;
        }
        
        .controls h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
        
        .controls p {
            margin: 5px 0;
            font-size: 10px;
        }
        
        .legend {
            padding: 15px 20px;
        }
        
        .legend h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-white);
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        .legend-safe {
            color: var(--text-controls);
        }
        
        .legend-danger {
            color: var(--text-score);
        }
        
        button {
            margin-top: 10px;
        }
        
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                gap: 10px;
            }
            .sidebar {
                width: 100%;
                max-width: 400px;
            }
            canvas {
                max-width: calc(100vw - 40px);
                max-height: calc(100vh - 250px);
            }
        }
    </style>
</head>
<body>
    <button class="menu-btn" id="menuBtn">Menu</button>
    <div class="menu-overlay" id="menuOverlay">
        <div class="menu-content">
            <h1 class="menu-title">üéÆ SELECT GAME</h1>
            <button class="menu-game-button" onclick="window.location.href='snake.html'">üêç Snake</button>
            <button class="menu-game-button" onclick="window.location.href='tetris.html'">üß© Tetris</button>
            <button class="menu-game-button" onclick="window.location.href='solitaire.html'">üÉè Solitaire</button>
            <button class="menu-game-button" onclick="window.location.href='frogger.html'">üê∏ Frogger</button>
            <button class="menu-game-button" onclick="closeMenu()">Cancel</button>
        </div>
    </div>
    <div class="game-container">
        <div style="position: relative;">
            <canvas id="gameCanvas"></canvas>
            <div id="gameOver" class="game-over">
                <h2>Game Over!</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <button onclick="startGame()">Play Again</button>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="score-panel">
                <h2>Frogger</h2>
                <div class="score-item">
                    Score: <span id="score">0</span>
                </div>
                <div class="score-item">
                    Distance: <span id="distance">0</span>
                </div>
            </div>
            
            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item legend-safe">
                    <div class="legend-color" style="background: #6b8e23;"></div>
                    <span>Grass - Safe to walk</span>
                </div>
                <div class="legend-item legend-danger">
                    <div class="legend-color" style="background: #663399;"></div>
                    <span>Purple Block - Obstacle (avoid)</span>
                </div>
                <div class="legend-item legend-danger">
                    <div class="legend-color" style="background: #000;"></div>
                    <span>Snake - Touch = Game Over</span>
                </div>
                <div class="legend-item legend-danger">
                    <div class="legend-color" style="background: #ff8c00;"></div>
                    <span>Orange Lava - Touch = Game Over</span>
                </div>
                <div class="legend-item legend-danger">
                    <div class="legend-color" style="background: #800000;"></div>
                    <span>Red Lava - Touch = Game Over</span>
                </div>
                <div class="legend-item legend-safe">
                    <div class="legend-color" style="background: #6b8e23; border: 2px solid #fff;"></div>
                    <span>Green Platform - Safe (moves)</span>
                </div>
            </div>
            
            <div class="controls">
                <h3>Controls</h3>
                <p>Arrow Keys: Move</p>
                <p>Score increases as you move forward</p>
                <button id="startBtn" onclick="startGame()">Start Game</button>
                <button id="pauseBtn" onclick="pauseGame()" disabled>Pause</button>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 30;
        const BOARD_WIDTH = 20;
        const VISIBLE_ROWS = 13;
        const ROWS_BEHIND_PLAYER = 3; // Number of rows to show behind player
        
        // Set canvas size based on grid
        canvas.width = BOARD_WIDTH * CELL_SIZE;
        canvas.height = VISIBLE_ROWS * CELL_SIZE;
        
        // Get colors from CSS variables
        function getCSSVariable(variable) {
            return getComputedStyle(document.documentElement)
                .getPropertyValue(variable).trim();
        }
        
        // Alien types from solitaire (one per suit)
        const ALIEN_TYPES = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
        
        // SVG aliens for each suit (from solitaire.html)
        function getAlienSVG(suit) {
            const svgs = {
                '‚ô•': `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <!-- Red alien with antennae -->
                    <rect x="10" y="16" width="20" height="16" fill="#d11" stroke="#000" stroke-width="1"/>
                    <rect x="12" y="12" width="6" height="6" fill="#d11" stroke="#000" stroke-width="1"/>
                    <rect x="22" y="12" width="6" height="6" fill="#d11" stroke="#000" stroke-width="1"/>
                    <rect x="16" y="22" width="8" height="6" fill="#000"/>
                    <line x1="15" y1="10" x2="15" y2="12" stroke="#000" stroke-width="2"/>
                    <line x1="25" y1="10" x2="25" y2="12" stroke="#000" stroke-width="2"/>
                    <circle cx="15" cy="9" r="2" fill="#000"/>
                    <circle cx="25" cy="9" r="2" fill="#000"/>
                </svg>`,
                '‚ô¶': `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <!-- Yellow/gold alien with angular body -->
                    <polygon points="12,28 28,28 24,20 20,12 16,20" fill="#f0a000" stroke="#000" stroke-width="1"/>
                    <rect x="18" y="20" width="4" height="8" fill="#000"/>
                    <rect x="14" y="16" width="4" height="4" fill="#000"/>
                    <rect x="22" y="16" width="4" height="4" fill="#000"/>
                </svg>`,
                '‚ô£': `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <!-- Green alien with multiple eyes -->
                    <rect x="10" y="18" width="20" height="14" fill="#00f000" stroke="#000" stroke-width="1"/>
                    <rect x="12" y="14" width="6" height="6" fill="#00f000" stroke="#000" stroke-width="1"/>
                    <rect x="22" y="14" width="6" height="6" fill="#00f000" stroke="#000" stroke-width="1"/>
                    <rect x="16" y="24" width="8" height="4" fill="#000"/>
                    <circle cx="15" cy="17" r="2" fill="#000"/>
                    <circle cx="19" cy="17" r="2" fill="#000"/>
                    <circle cx="21" cy="17" r="2" fill="#000"/>
                    <circle cx="25" cy="17" r="2" fill="#000"/>
                </svg>`,
                '‚ô†': `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <!-- Blue alien with wings -->
                    <ellipse cx="20" cy="22" rx="10" ry="10" fill="#3434FF" stroke="#000" stroke-width="1"/>
                    <rect x="16" y="18" width="8" height="6" fill="#000"/>
                    <polygon points="6,20 10,22 6,24" fill="#3434FF" stroke="#000" stroke-width="1"/>
                    <polygon points="34,20 30,22 34,24" fill="#3434FF" stroke="#000" stroke-width="1"/>
                    <polygon points="6,22 10,20 10,24" fill="#25233a" stroke="#000" stroke-width="1"/>
                    <polygon points="34,22 30,20 30,24" fill="#25233a" stroke="#000" stroke-width="1"/>
                    <circle cx="17" cy="21" r="1.5" fill="#fff"/>
                    <circle cx="23" cy="21" r="1.5" fill="#fff"/>
                </svg>`
            };
            return svgs[suit] || '';
        }
        
        // Colors
        const GRASS_COLOR = '#6b8e23';
        const OBSTACLE_COLOR = '#663399';
        const LAVA_ORANGE = '#ff8c00';
        const LAVA_RED = '#800000';
        const SNAKE_COLOR = getCSSVariable('--snake-color');
        const SNAKE_HEAD_COLOR = getCSSVariable('--snake-head-color');
        
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let distance = 0;
        let playerX = Math.floor(BOARD_WIDTH / 2); // Grid X position
        let playerY = 0; // Grid Y position (0 = starting row, increases as player moves forward)
        let currentAlienType = '‚ô•';
        let rows = []; // Array of row objects
        let cameraY = 0; // Camera offset in grid units
        let lastScrollTime = 0;
        let gameStartTime = 0;
        
        // Row types
        const ROW_TYPE = {
            GRASS: 'grass',
            SNAKE: 'snake',
            LAVA: 'lava'
        };
        
        // Create a row
        function createRow(type, y) {
            const row = {
                type: type,
                y: y,
                obstacles: [],
                snakes: [],
                platforms: [],
                direction: Math.random() > 0.5 ? 1 : -1 // For snakes and platforms
            };
            
            if (type === ROW_TYPE.GRASS) {
                // Grass row with obstacles
                let grassCount = 0;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (Math.random() < 0.3 && grassCount < 6) {
                        row.obstacles.push({x: x, width: 1});
                        grassCount++;
                    }
                }
                // Ensure path is possible
                ensurePathExists(row);
            } else if (type === ROW_TYPE.SNAKE) {
                // Snake row
                let x = 0;
                const spacing = 2 + Math.floor(Math.random() * 3); // 2-4 blocks
                while (x < BOARD_WIDTH) {
                    const snakeLength = 3 + Math.floor(Math.random() * 3); // 3-5 blocks
                    if (x + snakeLength <= BOARD_WIDTH) {
                        row.snakes.push({
                            x: x,
                            length: snakeLength,
                            speed: spacing === 2 ? 0.15 : (spacing === 3 ? 0.12 : 0.1) // Much slower speeds
                        });
                    }
                    x += snakeLength + spacing;
                }
            } else if (type === ROW_TYPE.LAVA) {
                // Lava row with platforms
                let x = 0;
                const isOrange = Math.random() > 0.5;
                while (x < BOARD_WIDTH) {
                    const platformSize = 2 + Math.floor(Math.random() * 3); // 2-4 blocks
                    if (x + platformSize <= BOARD_WIDTH) {
                        row.platforms.push({
                            x: x,
                            width: platformSize,
                            speed: 0.05 + Math.random() * 0.05 // Much slower speeds (0.05-0.1)
                        });
                    }
                    x += platformSize + Math.floor(Math.random() * 3) + 1;
                }
                // Ensure path is possible
                ensureLavaPathExists(row);
            }
            
            return row;
        }
        
        // Ensure path exists in grass row
        function ensurePathExists(row) {
            let hasPath = false;
            for (let x = 0; x < BOARD_WIDTH; x++) {
                let blocked = false;
                for (let obs of row.obstacles) {
                    if (x >= obs.x && x < obs.x + obs.width) {
                        blocked = true;
                        break;
                    }
                }
                if (!blocked) {
                    hasPath = true;
                    break;
                }
            }
            if (!hasPath) {
                // Clear middle section
                const mid = Math.floor(BOARD_WIDTH / 2);
                row.obstacles = row.obstacles.filter(obs => obs.x < mid - 2 || obs.x > mid + 2);
            }
        }
        
        // Ensure path exists in lava row
        function ensureLavaPathExists(row) {
            // Check if there's a continuous path
            let hasPath = false;
            for (let x = 0; x < BOARD_WIDTH; x++) {
                let canCross = false;
                for (let platform of row.platforms) {
                    if (x >= platform.x && x < platform.x + platform.width) {
                        canCross = true;
                        break;
                    }
                }
                if (canCross) {
                    hasPath = true;
                    break;
                }
            }
            if (!hasPath) {
                // Add a platform in the middle
                const mid = Math.floor(BOARD_WIDTH / 2);
                row.platforms.push({x: mid - 1, width: 3, speed: 0.7});
            }
        }
        
        // Initialize game rows
        function initRows() {
            rows = [];
            // Create initial rows (bottom row is index 0, goes up)
            for (let i = 0; i < VISIBLE_ROWS + 5; i++) {
                let type;
                if (i < 2) {
                    type = ROW_TYPE.GRASS; // Safe starting area
                } else {
                    const rand = Math.random();
                    if (rand < 0.4) {
                        type = ROW_TYPE.GRASS;
                    } else if (rand < 0.7) {
                        type = ROW_TYPE.SNAKE;
                    } else {
                        type = ROW_TYPE.LAVA;
                    }
                }
                rows.push(createRow(type, i));
            }
            
            // Ensure no more than 4 snake rows
            const snakeRows = rows.filter(r => r.type === ROW_TYPE.SNAKE);
            if (snakeRows.length > 4) {
                const excess = snakeRows.length - 4;
                let changed = 0;
                for (let i = 0; i < rows.length && changed < excess; i++) {
                    if (rows[i].type === ROW_TYPE.SNAKE && rows[i].y >= 2) {
                        rows[i] = createRow(ROW_TYPE.GRASS, rows[i].y);
                        changed++;
                    }
                }
            }
            
            // Alternate snake directions
            let snakeIndex = 0;
            for (let row of rows) {
                if (row.type === ROW_TYPE.SNAKE) {
                    row.direction = snakeIndex % 2 === 0 ? 1 : -1;
                    snakeIndex++;
                }
            }
        }
        
        // Draw cell
        function drawCell(x, y, color, outline = false) {
            const pixelX = x * CELL_SIZE;
            const pixelY = y * CELL_SIZE;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
            if (outline) {
                ctx.strokeStyle = getCSSVariable('--border-white');
                ctx.lineWidth = 2;
                ctx.strokeRect(pixelX + 1, pixelY + 1, CELL_SIZE - 2, CELL_SIZE - 2);
            }
        }
        
        // Draw snake segment
        function drawSnakeSegment(x, y, isHead = false) {
            const pixelX = x * CELL_SIZE;
            const pixelY = y * CELL_SIZE;
            ctx.fillStyle = isHead ? SNAKE_HEAD_COLOR : SNAKE_COLOR;
            ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
            ctx.strokeStyle = isHead ? getCSSVariable('--border-white') : '#a1a1a1';
            ctx.lineWidth = 2;
            ctx.strokeRect(pixelX + 1, pixelY + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        }
        
        // Draw alien as SVG (using Image approach)
        const alienImages = {}; // Cache for loaded images
        
        function loadAlienImage(suit) {
            if (alienImages[suit]) return alienImages[suit];
            const svg = getAlienSVG(suit);
            const img = new Image();
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            img.src = url;
            alienImages[suit] = {img, url};
            return alienImages[suit];
        }
        
        function drawAlien(x, y, suit) {
            const pixelX = x * CELL_SIZE;
            const pixelY = y * CELL_SIZE;
            const alienSize = CELL_SIZE * 0.8;
            const offsetX = pixelX + (CELL_SIZE - alienSize) / 2;
            const offsetY = pixelY + (CELL_SIZE - alienSize) / 2;
            
            const alienData = loadAlienImage(suit);
            if (alienData.img.complete) {
                ctx.drawImage(alienData.img, offsetX, offsetY, alienSize, alienSize);
            } else {
                alienData.img.onload = () => {
                    ctx.drawImage(alienData.img, offsetX, offsetY, alienSize, alienSize);
                };
            }
        }
        
        // Draw game - showing preview ahead and history behind
        function draw() {
            // Clear canvas
            ctx.fillStyle = getCSSVariable('--bg-canvas');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Player is positioned near bottom, showing rows behind and ahead
            // Top of screen (screenY = 0) shows rows ahead (higher gridY)
            // Bottom of screen (screenY = VISIBLE_ROWS - 1) shows rows behind (lower gridY)
            // Player is at screenY = VISIBLE_ROWS - 1 - ROWS_BEHIND_PLAYER
            
            const playerScreenY = VISIBLE_ROWS - 1 - ROWS_BEHIND_PLAYER;
            
            for (let screenY = 0; screenY < VISIBLE_ROWS; screenY++) {
                // Calculate grid Y: 
                // Top screen (screenY = 0) = furthest ahead = playerY + (VISIBLE_ROWS - 1 - ROWS_BEHIND_PLAYER)
                // Bottom screen (screenY = VISIBLE_ROWS - 1) = furthest behind = playerY - ROWS_BEHIND_PLAYER
                // Player row (screenY = playerScreenY) = playerY
                const gridY = playerY + (VISIBLE_ROWS - 1 - ROWS_BEHIND_PLAYER) - screenY;
                
                // Find row at this grid Y position
                let row = null;
                for (let r of rows) {
                    if (r.y === gridY) {
                        row = r;
                        break;
                    }
                }
                
                if (!row) {
                    // Draw grass if no row found
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        drawCell(x, screenY, GRASS_COLOR);
                    }
                    continue;
                }
                
                if (row.type === ROW_TYPE.GRASS) {
                    // Draw grass background
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        drawCell(x, screenY, GRASS_COLOR);
                    }
                    // Draw obstacles
                    for (let obs of row.obstacles) {
                        for (let x = obs.x; x < obs.x + obs.width && x < BOARD_WIDTH; x++) {
                            drawCell(x, screenY, OBSTACLE_COLOR);
                        }
                    }
                } else if (row.type === ROW_TYPE.SNAKE) {
                    // Draw grass background
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        drawCell(x, screenY, GRASS_COLOR);
                    }
                    // Draw snakes
                    for (let snake of row.snakes) {
                        const snakeX = Math.floor(snake.x);
                        for (let j = 0; j < snake.length; j++) {
                            let drawX = snakeX + j;
                            if (drawX < 0) drawX += BOARD_WIDTH;
                            if (drawX >= BOARD_WIDTH) drawX -= BOARD_WIDTH;
                            drawSnakeSegment(drawX, screenY, j === 0);
                        }
                    }
                } else if (row.type === ROW_TYPE.LAVA) {
                    // Draw lava pattern
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        const isOrange = (x + gridY) % 2 === 0;
                        drawCell(x, screenY, isOrange ? LAVA_ORANGE : LAVA_RED);
                    }
                    // Draw platforms
                    for (let platform of row.platforms) {
                        const platformX = Math.floor(platform.x);
                        for (let x = platformX; x < platformX + platform.width && x < BOARD_WIDTH; x++) {
                            let drawX = x;
                            if (drawX < 0) drawX += BOARD_WIDTH;
                            if (drawX >= BOARD_WIDTH) drawX -= BOARD_WIDTH;
                            drawCell(drawX, screenY, GRASS_COLOR);
                        }
                    }
                }
            }
            
            // Draw player at their screen position
            drawAlien(playerX, playerScreenY, currentAlienType);
        }
        
        // Update game
        function update(deltaTime) {
            if (!gameRunning || gamePaused) return;
            
            // Update snake positions
            for (let row of rows) {
                if (row.type === ROW_TYPE.SNAKE) {
                    for (let snake of row.snakes) {
                        snake.x += snake.speed * row.direction * deltaTime * 0.01;
                        if (snake.x < -snake.length) {
                            snake.x = BOARD_WIDTH;
                        } else if (snake.x > BOARD_WIDTH) {
                            snake.x = -snake.length;
                        }
                    }
                } else if (row.type === ROW_TYPE.LAVA) {
                    for (let platform of row.platforms) {
                        platform.x += platform.speed * row.direction * deltaTime * 0.01;
                        if (platform.x < -platform.width) {
                            platform.x = BOARD_WIDTH;
                        } else if (platform.x > BOARD_WIDTH) {
                            platform.x = -platform.width;
                        }
                    }
                }
            }
            
            // Auto-scroll based on time
            const currentTime = Date.now();
            const elapsedTime = currentTime - gameStartTime;
            let scrollInterval;
            if (elapsedTime < 30000) {
                scrollInterval = 5000; // 5 seconds
            } else if (elapsedTime < 60000) {
                scrollInterval = 4000; // 4 seconds
            } else if (elapsedTime < 90000) {
                scrollInterval = 3000; // 3 seconds
            } else {
                scrollInterval = 2000; // 2 seconds
            }
            
            if (currentTime - lastScrollTime > scrollInterval) {
                scrollUp();
                lastScrollTime = currentTime;
            }
            
            // Check collisions
            checkCollisions();
        }
        
        // Scroll up (add new rows ahead and remove old rows behind as player progresses)
        function scrollUp() {
            // Increment playerY to shift the world upward (player stays in place, world moves)
            playerY++;
            
            // Find highest row Y
            let maxY = 0;
            for (let row of rows) {
                if (row.y > maxY) maxY = row.y;
            }
            
            // Add new row ahead of player
            const newY = maxY + 1;
            let type;
            const rand = Math.random();
            if (rand < 0.4) {
                type = ROW_TYPE.GRASS;
            } else if (rand < 0.7) {
                type = ROW_TYPE.SNAKE;
            } else {
                type = ROW_TYPE.LAVA;
            }
            
            // Check snake row limit
            const snakeRows = rows.filter(r => r.type === ROW_TYPE.SNAKE);
            if (type === ROW_TYPE.SNAKE && snakeRows.length >= 4) {
                type = Math.random() > 0.5 ? ROW_TYPE.GRASS : ROW_TYPE.LAVA;
            }
            
            rows.push(createRow(type, newY));
            
            // Remove old rows that are too far behind player (keep buffer for viewing)
            const minVisibleY = playerY - ROWS_BEHIND_PLAYER - 5;
            rows = rows.filter(r => r.y >= minVisibleY);
            
            // Alternate snake directions
            let snakeIndex = 0;
            for (let row of rows) {
                if (row.type === ROW_TYPE.SNAKE) {
                    row.direction = snakeIndex % 2 === 0 ? 1 : -1;
                    snakeIndex++;
                }
            }
        }
        
        // Get row at grid Y position
        function getRowAt(gridY) {
            for (let row of rows) {
                if (row.y === gridY) {
                    return row;
                }
            }
            return null;
        }
        
        // Check collisions
        function checkCollisions() {
            const playerGridY = playerY; // Player's current grid Y position
            const row = getRowAt(playerGridY);
            
            if (!row) return;
            
            if (row.type === ROW_TYPE.GRASS) {
                // Check obstacle collision - obstacles block movement
                // This is handled in movePlayer by checking before moving
            } else if (row.type === ROW_TYPE.SNAKE) {
                // Check snake collision - need to check all snake segments
                for (let snake of row.snakes) {
                    const snakeStartX = snake.x;
                    for (let j = 0; j < snake.length; j++) {
                        let snakeCellX = Math.floor(snakeStartX + j);
                        // Handle wrapping
                        while (snakeCellX < 0) snakeCellX += BOARD_WIDTH;
                        while (snakeCellX >= BOARD_WIDTH) snakeCellX -= BOARD_WIDTH;
                        
                        // Check if player is at this snake cell position
                        if (snakeCellX === playerX) {
                            endGame();
                            return;
                        }
                    }
                }
            } else if (row.type === ROW_TYPE.LAVA) {
                // Check if on platform
                let onPlatform = false;
                for (let platform of row.platforms) {
                    const platformStartX = Math.floor(platform.x);
                    const platformEndX = platformStartX + platform.width;
                    
                    // Handle wrapping
                    let checkStartX = platformStartX;
                    let checkEndX = platformEndX;
                    if (checkStartX < 0) {
                        checkStartX += BOARD_WIDTH;
                        checkEndX += BOARD_WIDTH;
                    }
                    
                    // Check if player is on platform (handle wrapping)
                    if (playerX >= checkStartX && playerX < checkEndX) {
                        onPlatform = true;
                        // Move player with platform
                        playerX += platform.speed * row.direction * 0.005;
                        if (playerX < 0) playerX = BOARD_WIDTH - 1;
                        if (playerX >= BOARD_WIDTH) playerX = 0;
                        break;
                    } else if (checkEndX > BOARD_WIDTH) {
                        // Platform wraps around
                        if (playerX >= 0 && playerX < (checkEndX - BOARD_WIDTH)) {
                            onPlatform = true;
                            playerX += platform.speed * row.direction * 0.005;
                            if (playerX < 0) playerX = BOARD_WIDTH - 1;
                            if (playerX >= BOARD_WIDTH) playerX = 0;
                            break;
                        }
                    }
                }
                if (!onPlatform) {
                    // Touching lava - game over
                    endGame();
                    return;
                }
            }
        }
        
        // Move player
        function movePlayer(dx, dy) {
            if (!gameRunning || gamePaused) return;
            
            const newX = Math.max(0, Math.min(BOARD_WIDTH - 1, playerX + dx));
            let newY = playerY + dy;
            
            // Can't move below bottom
            if (newY < 0) {
                newY = 0;
            }
            
            // Check if moving forward (up)
            if (dy > 0 && newY > playerY) {
                score += 10;
                distance++;
                document.getElementById('score').textContent = score;
                document.getElementById('distance').textContent = distance;
            }
            
            // Check obstacle collision before moving
            const checkGridY = newY;
            const checkRow = getRowAt(checkGridY);
            if (checkRow && checkRow.type === ROW_TYPE.GRASS) {
                for (let obs of checkRow.obstacles) {
                    if (newX >= obs.x && newX < obs.x + obs.width) {
                        // Blocked by obstacle
                        return;
                    }
                }
            }
            
            playerX = newX;
            playerY = newY;
            
            checkCollisions();
        }
        
        // Start game
        function startGame() {
            // Random alien type
            currentAlienType = ALIEN_TYPES[Math.floor(Math.random() * ALIEN_TYPES.length)];
            
            gameRunning = true;
            gamePaused = false;
            score = 0;
            distance = 0;
            playerX = Math.floor(BOARD_WIDTH / 2);
            playerY = 0; // Start at row 0
            lastScrollTime = Date.now();
            gameStartTime = Date.now();
            
            document.getElementById('score').textContent = score;
            document.getElementById('distance').textContent = distance;
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('pauseBtn').textContent = 'Pause';
            
            initRows();
        }
        
        // Pause game
        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? 'Resume' : 'Pause';
        }
        
        // End game
        function endGame() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').classList.add('show');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        }
        
        // Game loop
        let lastTime = 0;
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Handle Enter key to start new game (works anytime)
            if (e.key === 'Enter') {
                e.preventDefault();
                startGame();
                return;
            }
            
            // Handle Space key to pause/resume (works when game is running)
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                if (gameRunning) {
                    pauseGame();
                }
                return;
            }
            
            // Prevent default for arrow keys
            if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(e.key)) {
                e.preventDefault();
            }
            
            // Only handle movement when game is running and not paused
            if (!gameRunning || gamePaused) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
                case 'ArrowUp':
                    movePlayer(0, 1); // Up increases Y (forward)
                    break;
                case 'ArrowDown':
                    movePlayer(0, -1); // Down decreases Y (backward)
                    break;
            }
        });
        
        // Initialize game state
        currentAlienType = ALIEN_TYPES[Math.floor(Math.random() * ALIEN_TYPES.length)];
        playerX = Math.floor(BOARD_WIDTH / 2);
        playerY = 0;
        initRows();
        
        // Preload alien images
        ALIEN_TYPES.forEach(suit => loadAlienImage(suit));
        
        draw();
        gameLoop();
        
        // Menu functionality
        function openMenu() {
            document.getElementById('menuOverlay').classList.add('show');
        }
        function closeMenu() {
            document.getElementById('menuOverlay').classList.remove('show');
        }
        document.getElementById('menuBtn').addEventListener('click', openMenu);
        document.getElementById('menuOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'menuOverlay') {
                closeMenu();
            }
        });
    </script>
</body>
</html>

